{
    function extractOptional(optional, index) {
        return optional ? optional[index] : null;
    }

    function extractList(list, index) {
        var result = new Array(list.length), i;

        for (i = 0; i < list.length; i++) {
           result[i] = list[i][index];
        }

        return result;
    }

    function buildList(head, tail, index) {
        return [head].concat(extractList(tail, index));
    }

    function optionalList(value) {
        return value !== null ? value : [];
    }

      function buildTree(head, tail, builder) {
        var result = head, i;

        for (i = 0; i < tail.length; i++) {
          result = builder(result, tail[i]);
        }

        return result;
      }
}

Start
    = __ program:Program __ { return program; }

/* ----- Lexical grammar ----- */

/* Tokens */

ElseToken       = "else"       !IdentifierPart
FalseToken      = "false"      !IdentifierPart
ForToken        = "for"        !IdentifierPart
FunctionToken   = "function"   !IdentifierPart
IfToken         = "if"         !IdentifierPart
ReturnToken     = "return"     !IdentifierPart

TypeDefinition
    = "string" _ [0-9]*
    / "array" _ [0-9]*
    / "integer"
    / "boolean"
    / "longint"
    / "val"
    / "date"

AssignmentOperator
  = "*="
  / "/="
  / "%="
  / "+="
  / "-="
  / "<<="
  / ">>="
  / ">>>="
  / "&="
  / "^="
  / "|="

SourceCharacter
    = .

ReservedWord "reserved word"
    = "ololo"

IdentifierStart
    = [a-zA-Z]
    / "$"
    / "_"

IdentifierPart
    = IdentifierStart
    / [0-9]

EOS
    = __ ";"
    / _ LineTerminatorSequence
    / __ EOF



LineTerminatorSequence "end of line"
    = "\n"
    / "\r\n"
    / "\r"

EOF
    = !.

_
    = (WhiteSpace)*

__
    = (WhiteSpace / LineTerminatorSequence)*

WhiteSpace
    = " "


Identifier
    = !ReservedWord name:IdentifierName { return name; }

IdentifierName "identifier"
    = head:IdentifierStart tail:IdentifierPart* {
        return {
          type: "Identifier",
          name: head + tail.join("")
        };
      }

/* ----- Statements ----- */

Statement
  = VariableStatement
  / ExpressionStatement
  / ReturnStatement

VariableStatement
    = TypeDefinition __ declarations:VariableDeclarationList EOS {
        return {
            type:         "VariableDeclaration",
            declarations: declarations,
            kind: "let"
        };
    }

VariableDeclarationList
    = head:VariableDeclaration tail:(__ "," __ VariableDeclaration)* {
        return buildList(head, tail, 3);
    }

VariableDeclaration
    = id:Identifier {
        return {
            type: "VariableDeclarator",
            id:   id
        };
    }

LeftHandSideExpression
  = CallExpression


CallExpression
  = head:(
      callee: MemberExpression  __ args:Arguments {
        return { type: "CallExpression", callee: callee, arguments: args };
      }
    )
    tail:(
        __ args:Arguments {
          return { type: "CallExpression", arguments: args };
        }
      / __ "[" __ property:Expression __ "]" {
          return {
            type:     "MemberExpression",
            property: property,
            computed: true
          };
        }
      / __ "." __ property:IdentifierName { 
          return {
            type:     "MemberExpression",
            property: property,
            computed: false
          };
        }
    )*
    {
      return buildTree(head, tail, function(result, element) {
        element[TYPES_TO_PROPERTY_NAMES[element.type]] = result;

        return element;
      });
    }

PrimaryExpression
  = Identifier
  / "(" __ expression:Expression __ ")" { return expression; }

MemberExpression
  = head:(
        PrimaryExpression 
    )
    tail:(
        __ "[" __ property:Expression __ "]" {
          return { property: property, computed: true };
        }
      / __ "." __ property:IdentifierName {
          return { property: property, computed: false };
        }
    )*
    {
      return buildTree(head, tail, function(result, element) {
        return {
          type:     "MemberExpression",
          object:   result,
          property: element.property,
          computed: element.computed
        };
      });
    }

Arguments
  = "(" __ args:(ArgumentList __)? ")" {
      return optionalList(extractOptional(args, 0));
    }
ArgumentList
  = head:AssignmentExpression tail:(__ "," __ AssignmentExpression)* {
      return buildList(head, tail, 3);
    }

ExpressionStatement
  =expression:Expression EOS {
      return {
        type:       "ExpressionStatement",
        expression: expression
      };
    }

Expression
  = head:AssignmentExpression tail:(__ "," __ AssignmentExpression)* {
      return tail.length > 0
        ? { type: "SequenceExpression", expressions: buildList(head, tail, 3) }
        : head;
    }

AssignmentExpression
  = left:LeftHandSideExpression  __
    "=" !"=" __
    right:AssignmentExpression
    {
      return {
        type:     "AssignmentExpression",
        operator: "=",
        left:     left,
        right:    right
      };
    } 

ReturnStatement
    = ReturnToken EOS {
        return { type: "ReturnStatement", argument: null };
    }

/* ----- Functions and Programs ----- */

FunctionDeclaration
  = FunctionToken __ TypeDefinition __ id:Identifier __
    "(" __ params:(FormalParameterList __)? ")" __
    "begin" __ body:FunctionBody __ "end" __ EOS
    {
      return {
        type:   "FunctionDeclaration",
        id:     id,
        params: optionalList(extractOptional(params, 0)),
        body:   body
      };
    }

FormalParameterList
    = TypeDefinition __ head:Identifier tail:(__ "," TypeDefinition __ Identifier)* {
        return buildList(head, tail, 3);
    }

FunctionBody
    = body:SourceElements? {
        return {
            type: "BlockStatement",
            body: optionalList(body)
        };
    }

Program
    = body:SourceElements? {
        return {
            type: "File",
            program: {
                type: "Program",
                body: optionalList(body)
            }
        };
    }

SourceElements
    = head:SourceElement tail:(__ SourceElement)* {
        return buildList(head, tail, 1);
    }

SourceElement
  = Statement
  / FunctionDeclaration
